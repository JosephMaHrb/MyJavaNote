[TOC]

# Q1 面向对象和面向过程的区别？
二者编程思维不同。面向过程直接编写问题的解决逻辑，而面向对象创造拥有各自职责的对象，通过对象之间的协作解决问题。面向对象方法带来了封装，继承和多态性的特性，更便于维护和拓展。
面向对象有对象的初始化开销，性能有可能低于面向过程语言。
## Q1.1 Java对象初始化做了哪些事情，有什么开销？
对象的初始化分为两部分，一是类的初始化，二是对象的初始化。
类的加载过程主要做3件事:
1. 通过类的权限定名来获取定义此类的二进制字节流
2. 将字节流代表的静态存储结构转化为方法区的运行时数据结构
3. 在内存中生成一个Class对象，作为方法区这个类的各种数据的访问入口
类的准备过程：

### Q1.1.1 获取二进制字节流的方式有哪些方式？
Java虚拟机并没有具体要求类初始化的实现，获取二进制字节流主要有以下方式：
1. 从Zip包读取，也是Jar，War的基础
2. 从网络获取，Applet
3. 运行时动态生成，动态代理技术
4. 其他文件生成，如JSP
5. 数据库读取，以此完成程序代码在集群中的分发

#### Q1.1.1.1 数组的加载方式与其他类有什么不同吗？
数组类本身不通过类加载器加载，而是Java虚拟机直接创建的。
如果数组的ComponentType是引用类型，则递归的加载之。该数组类会在其ComponentType的类加载器的命名空间上被标识。
如果ComponentType不是引用类型，则数组类会与引导类加载器关联。
数组类的可见性也与其ComponentType可见性一致。若非引用类型则默认为public。

### Q1.1.2 什么是字节流代表的静态存储结构, 介绍Class文件的结构？
### Q1.1.3 Java虚拟机运行时数据区是如何划分的?
Java的内存区域划分：
1. Program Counter Register
2. Method Area 
    - 线程共享
    - 存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据
3. VM Stack
    - 生命周期和线程相同
    - 每个方法在执行时创建一个栈帧（Stack Frame）用于存储局部变量表，操作数栈，动态链接，方法出口等信息，每一个方法从调用直至执行完成，对应一个栈帧在VM Stack中入栈到出栈
4. Native Method Stack
    - VM Stack 的Native方法版本
5. Heap
6. Runtime Constant Pool
    - 方法区的一部分， Class文件除了类的版本，字段，方法，接口等描述信息外，还有Constant Pool Table， 用于存放编译期间生成的字面量和符号引用。这部分在类加载后进入方法区的运行常量池存放。
7. Direct Memory
    - JDK1.4中引入了NIO（New Input/Output)，基于Channel和Buffer的IO方式，它可以使用Native函数库直接分配堆外内存，然后通过存储在堆中的DirectByteBuffer对象作为这块内存的引用进行操作。避免了在Java堆和Native堆间来回复制数据。
    - 不受Java堆大小的限制
#### Q1.1.3.1 Java可能发生内存溢出的区域？
1. 程序计数器不会发生内存溢出。
2. VM Stack 和 Native Method Stack，当栈深度超过配置的最大深度时会抛出StackOverflowError，当拓展时无法申请到足够的内存会抛出OutOfMemoryError。
3. Heap OutOfMemoryError 
#### Q1.1.3.2 所有对象都在堆上分配吗
JIT编译器的发展和逃逸分析技术的逐渐成熟，栈上分配和标量替换的优化技术可能是例外
##### Q1.1.3.2.1 JIT编译器
##### Q1.1.3.2.2 逃逸分析技术
##### Q1.1.3.2.3 栈上分配
##### Q1.1.3.2.4 标量替换
##### Q1.1.3.2.5 如何配置堆大小，Java不同配置的意义？
-DargName=argVal 为标准参数，所有虚拟机必须实现且向后兼容 可以通过System.getProperty读取
-X 非标准参数：默认应当实现，但不保证一定实现和向后兼容
-XX 非Stable参数：各虚拟机实现不同，随时可能取消
##### Q1.1.3.2.5.1 System.getProperty 和System.getEnv 的区别？
System.getEnv 是系统环境配置，而System.getProperty是虚拟机的配置
#### Q1.1.3.3 Java堆是GC的主要区域，介绍GC算法
Java堆分为新生代和老年代，有Eden空间， From Survivor空间，To Survivor空间等。可能有线程私有的分配缓冲区(Thread Local Allocation Buffer, TLAB)
#### Q1.1.3.4 所有对象都在堆上分配吗
JIT编译器的发展和逃逸分析技术的逐渐成熟，栈上分配和标量替换的优化技术可能是例外
#### Q1.1.3.5 所有对象都在堆上分配吗
#### Q1.1.3.6 方法区和永久代等价么？
HotSpot虚拟机的设计团队使用永久代来实现方法区，来像管理堆一样管理这部分内存。不意味所有虚拟机都如此实现。另外永久代有 -XX:MaxPermSize的上限，这样可能更容易内存溢出
（JDK1.7的HotSpot中已经把原本放在永久代的字符串常量池移出）
#### Q1.1.3.7 方法区的垃圾回收主要对象是？
方法区的垃圾回收效率不高，主要目标是常量池的回收和对类型的卸载。
#### Q1.1.3.10 分析内存使用情况的主要方法？
top & free & jconsole
主要考虑 Non-Heap, Heap 和 Native Heap
#### Q1.1.3.11 DirectByteBuffer在销毁前如何处理内存
ByteBuffer.allocateDirect中，并没有使用finalize函数，而是使用更有安全保障的PhantomReference
### Q1.1.4 Class对象存放的位置是？
虚拟规范没有规定其存储位置，HotSpot虚拟机把Class对象存在方法区。